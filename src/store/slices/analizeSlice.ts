import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { AxiosResponse } from "axios";
import { SensorsReceiveTpe } from "../../components/pages/sensors/sensorsTable";
import { reportSensors } from "../api/analizeApi";
import { DevicesReceiveType } from "../api/devicesApi";

import type { AppState } from "../store";
// import { fetchCount } from './../counterAPI'

export interface AnalizeState {
  startDate?: string;
  endDate?: string;
  selectedDevices?: DevicesReceiveType[];
  statusApi: statusApiType;
  selectedSensors?: SensorsReceiveTpe[];
  sensorsReport?: SensorsReportType[];
  statusReportApi: statusApiType;
}
export interface SensorsReportType {
  _id?: string;
  data?: Datum[];
  sensor?: SensorInReport;
  device: DevicesReceiveType;
}

export interface Datum {
  x?: string;
  y?: number;
}

export interface SensorInReport {
  title?: string;
  type?: string;
  unit?: string;
  maxAlarm?: number;
  minAlarm?: number;
  resolution?: string;
  _id?: string;
  createdAt?: string;
  updatedAt?: string;
}

type statusApiType = "idle" | "loading" | "success" | "failed" | "unauthorize";
const initialState: AnalizeState = {
  statusApi: "idle",
  statusReportApi: "idle",
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const reportSensorsAsync = createAsyncThunk(
  "analize/reportSensors",

  async (report: { sensors: string[]; start: string; end: string }) => {
    const data = await reportSensors(report);
    // The value we return becomes the `fulfilled` action payload
    return data;
  }
);

export const analizeSlice = createSlice({
  name: "analize",
  initialState,

  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setStartDate: (state, action: PayloadAction<string>) => {
      state.startDate = action.payload;
    },
    setEndDate: (state, action: PayloadAction<string>) => {
      state.endDate = action.payload;
    },
    setSelectedDevicesAnalize: (
      state,
      action: PayloadAction<DevicesReceiveType[]>
    ) => {
      state.selectedDevices = action.payload;
    },
    setAnalizeApiStatus: (state, action: PayloadAction<statusApiType>) => {
      state.statusApi = action.payload;
    },
    setSelectedSensors: (state, action: PayloadAction<SensorsReceiveTpe[]>) => {
      state.selectedSensors = action.payload;
    },
    addSelectedSensors: (state, action: PayloadAction<SensorsReceiveTpe>) => {
      const arr: SensorsReceiveTpe[] = [...(state?.selectedSensors ?? [])];
      if (arr.findIndex((item) => item._id === action.payload._id) < 0) {
        arr.push(action.payload);
      }
      state.selectedSensors = [...arr];
    },
    removeSelectedSensors: (state, action: PayloadAction<string>) => {
      const arr: SensorsReceiveTpe[] = [];
      state?.selectedSensors?.map((sensor, index) => {
        if (sensor._id !== action.payload) {
          arr.push(sensor);
        }
      });
      state.selectedSensors = [...arr];
    },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.

  extraReducers: (builder) => {
    builder
      .addCase(reportSensorsAsync.pending, (state) => {
        state.statusReportApi = "loading";
      })
      .addCase(
        reportSensorsAsync.fulfilled,
        (state, action: PayloadAction<SensorsReportType[]>) => {
          state.sensorsReport = action.payload;
          state.statusReportApi = "success";
          // if (action?.payload?.status < 400) {
          //   state.statusReportApi = "success";
          //   state.sensorsReport = action.payload.data as SensorsReportType[];
          // } else {
          //   state.statusReportApi = "failed";
          // }
        }
      )
      .addCase(
        reportSensorsAsync.rejected,
        (state, action: PayloadAction<any>) => {
          state.statusReportApi = "failed";
          state.sensorsReport = undefined;
        }
      );
  },
});

export const {
  setStartDate,
  setEndDate,
  setSelectedDevicesAnalize,
  addSelectedSensors,
  setSelectedSensors,
  removeSelectedSensors,
} = analizeSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectStartDate = (state: AppState) => state.analize.startDate;
export const selectEndDate = (state: AppState) => state.analize.endDate;
export const selectSelectedDevicesAnalize = (state: AppState) =>
  state.analize.selectedDevices;
export const selectAnalizeApiStatus = (state: AppState) =>
  state.analize.statusApi;
export const selectSelectedSensorsAnalize = (state: AppState) =>
  state.analize.selectedSensors;
export const selectSensorReports = (state: AppState) =>
  state.analize.sensorsReport;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
//   (amount: number): AppThunk =>
//   (dispatch, getState) => {
//     const currentValue = selectCount(getState())
//     if (currentValue % 2 === 1) {
//       dispatch(incrementByAmount(amount))
//     }
//   }

export default analizeSlice.reducer;
