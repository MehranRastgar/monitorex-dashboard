import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { Order } from "../../types/types";
import {
  getCartPrices,
  getOrderByIdApi,
  getOrdersApi,
  updatedPrice,
  UpdatePriceRespons,
} from "../api/orderApi";
import { AppState } from "../store";

export type variantId = {
  id: string;
};

export const updateCartPrices = createAsyncThunk(
  "order/updateCartPrices",
  async (orderReq: variantId[]) => {
    const response:
      | UpdatePriceRespons[]
      | {
          error: {
            errorCode: any;
          };
        } = await getCartPrices(
      orderReq,
      String(localStorage?.getItem("accessToken")),
      String(localStorage?.getItem("user-id"))
    );

    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
//===================================================================
export const getOrders = createAsyncThunk(
  "order/getOrders",
  async ({ perpage, page }: { perpage: number; page: number }) => {
    const response:
      | Order[]
      | {
          error: {
            errorCode: any;
          };
        } = await getOrdersApi(
      perpage,
      page,
      String(localStorage?.getItem("accessToken")),
      String(localStorage?.getItem("user-id"))
    );

    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
export const getOrderById = createAsyncThunk(
  "order/getOrderById",
  async (orderId: string) => {
    const response:
      | Order
      | {
          error: {
            errorCode: any;
          };
        } = await getOrderByIdApi(
      orderId,
      String(localStorage?.getItem("accessToken")),
      String(localStorage?.getItem("user-id"))
    );

    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export interface OrderState {
  Orders: Order[];
  value: Order;
  updatedPrice: UpdatePriceRespons[];
  status: "success" | "loading" | "403" | "401" | "unknownError";
  token: "loading" | string;
  updateFlag:
    | "idle"
    | "request"
    | "success"
    | "pending"
    | "403"
    | "401"
    | "unknownError"
    | "faild";
}

const initialState: OrderState = {
  Orders: [],
  value: {},
  updatedPrice: [],
  updateFlag: "idle",
  status: "loading",
  token: "loading",
};

export const orderSlice = createSlice({
  name: "order",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    //   refreshToken: (state) => {},
    //   setMobileNumber: (state, action: PayloadAction<number>) => {
    //     state.value.usernamebyphone = action.payload;
    //   },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.

  extraReducers: (builder) => {
    builder
      .addCase(updateCartPrices.pending, (state) => {
        state.updateFlag = "pending";
      })
      .addCase(updateCartPrices.rejected, (state) => {
        state.updateFlag = "faild";
      })
      .addCase(
        updateCartPrices.fulfilled,
        (state, action: PayloadAction<UpdatePriceRespons[] | any>) => {
          if (action?.payload?.error === undefined) {
            state.updatedPrice = action.payload;
            state.updateFlag = "success";
          } else {
            state.updateFlag = "faild";
          }
        }
      )
      .addCase(getOrders.pending, (state) => {
        state.updateFlag = "pending";
      })
      .addCase(getOrders.rejected, (state) => {
        state.updateFlag = "faild";
      })
      .addCase(
        getOrders.fulfilled,
        (state, action: PayloadAction<Order[] | any>) => {
          if (action?.payload?.error === undefined) {
            state.Orders = action.payload;
            state.updateFlag = "success";
          } else {
            state.updateFlag = "faild";
          }
        }
      )
      .addCase(getOrderById.pending, (state) => {
        state.updateFlag = "pending";
      })
      .addCase(getOrderById.rejected, (state) => {
        state.updateFlag = "faild";
      })
      .addCase(
        getOrderById.fulfilled,
        (state, action: PayloadAction<Order | any>) => {
          if (action?.payload?.error === undefined) {
            state.value = action.payload;
            state.updateFlag = "success";
          } else {
            state.updateFlag = "faild";
          }
        }
      );
  },
});

export const {} = orderSlice.actions;

export const selectUserInfo = (state: AppState) => state.client.value;

export const selectUpdatedPrices = (state: AppState) =>
  state.order.updatedPrice;
export const selectUpdatedPricesFlag = (state: AppState) =>
  state.order.updateFlag;
export const selectOrders = (state: AppState) => state.order.Orders;
export const selectSpecOrder = (state: AppState) => state.order.value;

export default orderSlice.reducer;
