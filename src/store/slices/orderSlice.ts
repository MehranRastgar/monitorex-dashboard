import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import { Order } from "../../types/types";
import {
  getCartPrices,
  getOrderByIdApi,
  getOrdersApi,
  updatedPrice,
  UpdatePriceRespons,
} from "../api/orderApi";
import { AppState } from "../store";

export type variantId = {
  id: string;
};

export const updateCartPrices = createAsyncThunk(
  "order/updateCartPrices",
  async (orderReq: variantId[]) => {
    const response:
      | UpdatePriceRespons[]
      | {
        error: {
          errorCode: any;
        };
      } = await getCartPrices(
        orderReq,
        String(localStorage?.getItem("accessToken")),
        String(localStorage?.getItem("user-id"))
      );

    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
//===================================================================
export const getOrders = createAsyncThunk(
  "order/getOrders",
  async ({ perpage, page }: { perpage: number; page: number }) => {
    const response:
      | Order[]
      | {
        error: {
          errorCode: any;
        };
      } = await getOrdersApi(
        perpage,
        page,
        String(localStorage?.getItem("accessToken")),
        String(localStorage?.getItem("user-id"))
      );

    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);
export const getOrderById = createAsyncThunk(
  "order/getOrderById",
  async (orderId: string) => {
    const response:
      | Order
      | {
        error: {
          errorCode: any;
        };
      } = await getOrderByIdApi(
        orderId,
        String(localStorage?.getItem("accessToken")),
        String(localStorage?.getItem("user-id"))
      );

    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export interface OrderState {
  Orders: Order[];
  value: Order;
  updatedPrice: UpdatePriceRespons[];
  status: "success" | "loading" | "403" | "401" | "unknownError";
  token: "loading" | string;
  updateFlag:
  | "idle"
  | "request"
  | "success"
  | "pending"
  | "403"
  | "401"
  | "unknownError"
  | "faild";
}

const initialState: OrderState = {
  Orders: [],
  value: {},
  updatedPrice: [],
  updateFlag: "idle",
  status: "loading",
  token: "loading",
};

export const orderSlice = createSlice({
  name: "order",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    //   refreshToken: (state) => {},
    //   setMobileNumber: (state, action: PayloadAction<number>) => {
    //     state.value.usernamebyphone = action.payload;
    //   },
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.

  extraReducers: (builder) => {
    builder
      .addCase(updateCartPrices.pending, (state) => {
        state.updateFlag = "pending";
      })
      .addCase(updateCartPrices.rejected, (state) => {
        state.updateFlag = "faild";
      })
      .addCase(
        updateCartPrices.fulfilled,
        (state, action: PayloadAction<UpdatePriceRespons[] | any>) => {
          if (action?.payload?.error === undefined) {
            state.updatedPrice = action.payload;
            state.updateFlag = "success";
          } else {
            state.updateFlag = "faild";
          }
        }
      )
      .addCase(getOrders.pending, (state) => {
        state.updateFlag = "pending";
      })
      .addCase(getOrders.rejected, (state) => {
        state.updateFlag = "faild";
      })
      .addCase(
        getOrders.fulfilled,
        (state, action: PayloadAction<Order[] | any>) => {
          if (action?.payload?.error === undefined) {
            state.Orders = action.payload;
            state.updateFlag = "success";
          } else {
            state.updateFlag = "faild";
          }
        }
      )
      .addCase(getOrderById.pending, (state) => {
        state.updateFlag = "pending";
      })
      .addCase(getOrderById.rejected, (state) => {
        state.updateFlag = "faild";
      })
      .addCase(
        getOrderById.fulfilled,
        (state, action: PayloadAction<Order | any>) => {
          if (action?.payload?.error === undefined) {
            state.value = action.payload;
            state.updateFlag = "success";
          } else {
            state.updateFlag = "faild";
          }
        }
      );
  },
});

export const { } = orderSlice.actions;

export const selectUserInfo = (state: AppState) => state.client.value;

export const selectUpdatedPrices = (state: AppState) =>
  state.order.updatedPrice;
export const selectUpdatedPricesFlag = (state: AppState) =>
  state.order.updateFlag;
export const selectOrders = (state: AppState) => state.order.Orders;
export const selectSpecOrder = (state: AppState) => state.order.value;

export default orderSlice.reducer;
