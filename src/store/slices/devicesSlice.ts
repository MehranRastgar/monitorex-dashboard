import { createAsyncThunk, createSlice, PayloadAction } from "@reduxjs/toolkit";
import type { AppState, AppThunk } from "../store";
import type { PropertyProperty } from "../../types/types";
import { SensorsReceiveTpe } from "../../components/pages/sensors/sensorsTable";
import { fetchSensors } from "../api/sensorsApi";
import {
  DevicesReceiveType,
  Factor,
  getDevices,
  putDevice,
  removeDevice,
} from "../api/devicesApi";
import axios, { AxiosError, AxiosResponse } from "axios";
import { setSignInFlag } from "./clientSlice";
import { useAppDispatch } from "../hooks";

export type ApiFetchStatus =
  | "initial"
  | "request"
  | "rejected"
  | "success"
  | "faild"
  | "unauthorize";

export interface deviceAddress {
  multiPort: number;
  sMultiPort: number;
}
// export interface Device {
//   title: string;
//   address: deviceAddress;
//   type: "Electrical panel" | "Sensor Cotroller";
//   DeviceUniqueName: string;
//   factors: Factor[];
// }
export interface Devices {
  data: DevicesReceiveType[];
  status: ApiFetchStatus;
  selectedDevice: DevicesReceiveType;
  putStatus: ApiFetchStatus;
  alarms?: alarmsType[];
  amountOfSensors?: number;
  amountOfConnectSensors?: number;
  amountOfDisconnectSensors?: number;
  errorMessage?: string;
}
export interface alarmsType {
  message: string;
  value: number;
  sensorId: string;
  sensorTitle: string;
  counter?: number;
}
const initialState: Devices = {
  data: [],
  selectedDevice: {},
  status: "initial",
  putStatus: "initial",
};
interface ValidationErrors {
  errorMessage: string;
  field_errors: Record<string, string>;
}
// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const getDevicesAsync = createAsyncThunk(
  "devices/getDevices",

  async (): Promise<AxiosResponse | AxiosError> => {
    // The value we return becomes the `fulfilled` action payload

    const response = await getDevices();
    return response;
  }
);
export const putDeviceAsync = createAsyncThunk(
  "devices/putDevice",
  async (
    body: DevicesReceiveType,
    { rejectWithValue }
  ): Promise<AxiosResponse | AxiosError> => {
    const response = await putDevice(body, body?._id ?? undefined);
    return response;
  }
);
export const removeDeviceAsync = createAsyncThunk(
  "devices/putDevice",
  async (
    body: DevicesReceiveType,
    { rejectWithValue }
  ): Promise<AxiosResponse | AxiosError> => {
    const response = await removeDevice(body?._id);
    return response;
  }
);
export const devicesSlice = createSlice({
  name: "devices",
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    setDevicesData: (state, action: PayloadAction<DevicesReceiveType[]>) => {
      state.data = action.payload;
      let amount = 0;
      let number = 0;
      state.data.map((device) => {
        amount += device?.sensors?.length ?? 0;
        device?.sensorLastSerie?.map((item) => {
          if (item?.timestamp !== undefined) {
            const timedate = new Date(item?.timestamp);
            const now = new Date();
            const dif = now.getTime() - timedate.getTime();
            if (dif / 1000 / 60 < 15) number++;
          }
        });
      });
      state.amountOfSensors = amount;
      state.amountOfConnectSensors = number;
      state.amountOfDisconnectSensors = amount - number;
    },
    setDevicesStatus: (state, action: PayloadAction<ApiFetchStatus>) => {
      state.status = action.payload;
    },
    setSelectedDevice: (state, action: PayloadAction<DevicesReceiveType>) => {
      state.selectedDevice = action.payload;
    },
    setDevicesAlarms: (state, action: PayloadAction<alarmsType[]>) => {
      state.alarms = action.payload;
    },
    setDevicesAlarmsHandler: (state, action: PayloadAction<alarmsType>) => {
      let arr: alarmsType[] = [...(state.alarms ?? [])];
      const ind = arr.findIndex(
        (item) => item.sensorId === action.payload.sensorId
      );
      if (ind >= 0 && arr?.[ind]?.message === action?.payload?.message) {
        arr[ind] = {
          ...arr[ind],
          value: action?.payload?.value,
          counter: (arr?.[ind]?.counter ?? 0) + 1,
        };
      } else {
        arr.push(action.payload);
      }
      state.alarms = arr;
    },
    setErrorMessage: (state, action: PayloadAction<string>) => {
      state.errorMessage = action.payload;
    },
  },

  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.

  extraReducers: (builder) => {
    builder
      .addCase(putDeviceAsync.pending, (state) => {
        state.status = "request";
      })
      .addCase(
        putDeviceAsync.fulfilled,
        (state, action: PayloadAction<any>) => {
          if (action.payload.status < 400) {
            state.status = "success";
            state.selectedDevice = action.payload.data as DevicesReceiveType;
            state.errorMessage = "success";
          } else {
            state.status = "faild";
            state.errorMessage = action.payload?.message;
          }

          // state.categories = action?.payload?.[index] ?? [];
        }
      )
      .addCase(putDeviceAsync.rejected, (state, action: PayloadAction<any>) => {
        state.status = "rejected";
        state.errorMessage = "action.payload?.message";
        // state.errorMessage = "error rejected ";

        ////console.log(action.payload);

        // state.data = [];
      })
      .addCase(getDevicesAsync.pending, (state) => {
        state.status = "request";
      })
      .addCase(
        getDevicesAsync.fulfilled,
        (state, action: PayloadAction<any>) => {
          if (action?.payload?.status < 400) {
            state.status = "success";
            state.selectedDevice = action.payload.data as DevicesReceiveType;
            state.errorMessage = "success";
          } else {
            state.errorMessage = "unauthorize";
          }
        }
      )
      .addCase(
        getDevicesAsync.rejected,
        (state, action: PayloadAction<any>) => {
          state.status = "unauthorize";

          state.data = [];
        }
      );
  },
});

export const {
  setDevicesAlarmsHandler,
  setDevicesData,
  setSelectedDevice,
  setDevicesStatus,
  setDevicesAlarms,
  setErrorMessage,
} = devicesSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const selectDevicesData = (state: AppState) => state.devices.data;
export const selectDevicesStatus = (state: AppState) => state.devices.status;
export const selectSelectedDevice = (state: AppState) =>
  state.devices.selectedDevice;
export const selectDevicesLength = (state: AppState) =>
  state.devices.data?.length;
export const selectDevicesAlarms = (state: AppState) => state.devices.alarms;
export const selectAmountOfSensors = (state: AppState) =>
  state.devices.amountOfSensors;
export const selectAmountOfConnectSensors = (state: AppState) =>
  state.devices.amountOfConnectSensors;
export const selectAmountOfDisconnectSensors = (state: AppState) =>
  state.devices.amountOfDisconnectSensors;
export const selectErrorMessage = (state: AppState) =>
  state.devices.errorMessage;
// export const selectSensorsHasWork = (state: AppState) =>
//   state.devices.sensorHasWork;

// export const selectDevicesHasNotWork = (state: AppState) =>
//   state.devices.sensorHasNotWork;
// export const selectUserInfo = (state: AppState) => state.client.value;
// We can also write thunks by hand, which may contain both sync and async logi c.
// Here's an example of conditionally dispatching actions based on current state.
// export const incrementIfOdd =
//   (amount: number): AppThunk =>
//   (dispatch, getState) => {
//     const currentValue = selectCount(getState())
//     if (currentValue % 2 === 1) {
//       dispatch(incrementByAmount(amount))
//     }
//   }

export default devicesSlice.reducer;
